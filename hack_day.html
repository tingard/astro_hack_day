<!DOCTYPE html> 
<html> 
<head> 
<meta charset=utf-8>
<title>My first Three.js app</title>
<style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> 
<script style="text/javasript" src="js/PapaParse-4.1.2/papaparse.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script> 
<script src="http://astronomy.susx.ac.uk/~tl229/astro_hack_day/js/FlyControls.js"></script> 
<script>
    function async(arg, your_function, callback) {
        setTimeout(function() {
            your_function(arg);
            if (callback) {callback();}
        }, 0);
    }

    function coords_to_points(point_list){
        console.log('coords_to_points asyncronously called');
        var geometry = new THREE.BoxGeometry( .5, .5, .5 );
        var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
        var cube0 = new THREE.Mesh( geometry, material ); 
        scene.add(cube0)

        var point_geometry = new THREE.BufferGeometry();
        var num_points = point_list.length-1;
        var positions = new Float32Array( num_points*3 )
        var colors = new Float32Array( num_points*3 );
        for (i=1; i<point_list.length-1; i++){
            if (point_list[i].length < 1){ continue }
            x = point_list[i][1];
            y = point_list[i][2]
            z = point_list[i][3]
            dist2 = Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2);
            positions[3*i-3] = x;
            positions[3*i-2] = y;
            positions[3*i-1] = z;
            colors[3*i] = 1.0;
            colors[3*i+1] = 1.0;
            colors[3*i+2] = Math.random();
        }
        console.log(positions);
        point_geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        point_geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
        point_geometry.computeBoundingBox();
        var material = new THREE.PointsMaterial( { size: pointSize, vertexColors: THREE.VertexColors } );
        pointCloud = new THREE.Points( point_geometry, material );
        pointCloud.position.set( 0, 0, 0 );
        scene.add(pointCloud);
    }
    
    var foo; // variable which stores the read-in csv
    Papa.parse("http://astronomy.sussex.ac.uk/~tl229/astro_hack_day/cart_WP8_photoz_XMM_LSS.csv", {
        download: true,
        complete: function(results) {
            foo = results.data;
            console.log(foo);
            async(foo, coords_to_points);
        }
    })
    
    function onWindowResize( event ) {
        //SCREEN_HEIGHT = window.innerHeight;
        //SCREEN_WIDTH  = window.innerWidth;
        renderer.setSize(viewportWidth, viewportHeight);
        camera.updateProjectionMatrix();
    }

    

    var viewport;
    var controls;   //built-in three.js controls will be attached to this
    var mouseDown = 0;  //holds whether a mouse button is currently pressed (can be broken I think)
    var timer = new THREE.Clock(); // used so we don't raytrace every frame
    
    //viewport size
    var viewportWidth = window.innerWidth;
    var viewportHeight = window.innerHeight;

    //camera attributes
    var view_angle = 45,
        aspect = viewportWidth / viewportHeight,
        near = 0.1,//near clip-plane
        far = 100000;//far clip-plane


    //----Constructors----//
    var renderer = new THREE.WebGLRenderer({antialias: true});
    var scene = new THREE.Scene();
    scene.fog = new THREE.Fog( 0xff0101, 100, 10000 );
    var raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.2;

    var camera = new THREE.PerspectiveCamera(
    view_angle,
    aspect,
    near,
    far
    );
    
    var pointCloud;
    var mouse = new THREE.Vector2();
    var intersection = null;
    var pointSize = 0.2;
    
    // hover-over sphere
    var alphaTexture = new THREE.ImageUtils.loadTexture('alpha2.png');
    alphaTexture.wrapS = THREE.RepeatWrapping;
    alphaTexture.wrapT = THREE.RepeatWrapping;
    var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
    var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
    var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, shading: THREE.FlatShading } );
    var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, 
                                                        shading: THREE.FlatShading, 
                                                        alphaMap: alphaTexture, 
                                                        transparent: true } );
    var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
    scene.add( sphere );
    
    //a cross-browser method for efficient animation, more info at:
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       || 
              window.webkitRequestAnimationFrame || 
              window.mozRequestAnimationFrame    || 
              window.oRequestAnimationFrame      || 
              window.msRequestAnimationFrame     || 
              function( callback ){
                window.setTimeout(callback, 1000 / 60);
              };
    })();
    //----Initialization----//
    function initialize()
    {
        //Sets up the renderer to the same size as a DOM element
        //and attaches it to that element
        renderer.setSize(viewportWidth, viewportHeight);
        viewport = document.getElementById('viewport');
        viewport.appendChild(renderer.domElement);
        camera.position.z=5.;
        //attaches fly controls to the camera
        controls = new THREE.FlyControls( camera );
        //camera control properties
        controls.movementSpeed = 1;
        controls.domElement = viewport;
        controls.rollSpeed = 0.01;
        controls.autoForward = false;
        controls.dragToLook = true;

        //add the objects to the scene
        scene.add(camera);

        // call update
        update();
    }
    //----Update----//
    function update() {
        //requests the browser to call update at it's own pace
        requestAnimFrame( update );
        //update controls
        controls.update( 1 );
        //call draw
        draw();
    }
    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }
    var t = 0;
    function findIntersect(bar){
        raycaster.setFromCamera( mouse, camera );
        console.log(pointCloud);
        var intersections = raycaster.intersectObject( pointCloud );
        intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
        if (intersection && intersection.index){
            data_entry = foo[intersection.index+1];
            sphere.position.set(data_entry[1],data_entry[2],data_entry[3]);
            sphere.scale.set(4, 4, 4);
            //console.log(foo[intersection.index]);
        }
        t = timer.getElapsedTime();
    }
    //----Draw----//
    function draw() {
        if (!mouseDown && (timer.getElapsedTime()-t )> 0.5) {
            async(mouseDown, findIntersect); // mousedown only passed to satisfy async
        }
        renderer.render(scene, camera);
    }
    function onMouseDown(){
        //event.preventDefault();
        ++mouseDown; console.log('mousedown');
        console.log(pointCloud);
    }
    function onMouseUp(){
        //event.preventDefault();
        --mouseDown; console.log('mouseup');
    }
    window.addEventListener('resize', onWindowResize, false );
    window.addEventListener('mousemove', onDocumentMouseMove, false );
    document.addEventListener('mousedown', onMouseDown, false);
    document.addEventListener('mouseup', onMouseUp, false);
    window.requestAnimationFrame(draw);
</script> 
</head>
<body onload="initialize();">
<div id="viewport"></div>
</body>
</html>
