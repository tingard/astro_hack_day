<!DOCTYPE html> 
<html> 
<head> 
<meta charset=utf-8>
<title>I can show you the world</title>
<link rel="stylesheet" href="style.css">
<script style="text/javasript" src="js/PapaParse-4.1.2/papaparse.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script> 
<script src="http://astronomy.susx.ac.uk/~tl229/astro_hack_day/js/FlyControls.js"></script> 
<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute vec3 customColor;
    varying vec3 vColor;
    void main() {
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    uniform sampler2D texture;
    varying vec3 vColor;
    void main() {
        gl_FragColor = vec4( color * vColor, 1.0 );
        gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
    }
</script>
<script>
    function async(arg, your_function, callback) {
        setTimeout(function() {
            your_function(arg);
            if (callback) {callback();}
        }, 0);
    }

    function coords_to_points(point_list){
        console.log('coords_to_points asyncronously called');
        var geometry = new THREE.BoxGeometry( .5, .5, .5 );
        var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
        var cube0 = new THREE.Mesh( geometry, material ); 
        scene.add(cube0)

        var point_geometry = new THREE.BufferGeometry();
        var num_points = point_list.length-1;
        var positions = new Float32Array( num_points*3 )
        var colors = new Float32Array( num_points*3 );
        for (i=1; i<point_list.length-1; i++){
            if (point_list[i].length < 1){ continue }
            x = point_list[i][1];
            y = point_list[i][2]
            z = point_list[i][3]
            dist2 = Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2);
            positions[3*i-3] = x;
            positions[3*i-2] = y;
            positions[3*i-1] = z;
            colors[3*i] = 1.0;
            colors[3*i+1] = 1.0;
            colors[3*i+2] = Math.random();
        }
        uniforms = {
            color:     { type: "c", value: new THREE.Color( 0xffffff ) },
            texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "spark1.png" ) }
        };
        var shaderMaterial = new THREE.ShaderMaterial( {
            uniforms:       uniforms,
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.AdditiveBlending,
            depthTest:      false,
            transparent:    true
        });
        point_geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        point_geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        point_geometry.computeBoundingBox();
        var material = new THREE.PointsMaterial( { size: pointSize, vertexColors: THREE.VertexColors } );
        pointCloud = new THREE.Points( point_geometry, shaderMaterial );
        pointCloud.position.set( 0, 0, 0 );
        scene.add(pointCloud);
    }
    
    var foo; // variable which stores the read-in csv
    Papa.parse("http://astronomy.sussex.ac.uk/~tl229/astro_hack_day/cart_WP8_photoz_XMM_LSS.csv", {
        download: true,
        complete: function(results) {
            foo = results.data;
            async(foo, coords_to_points);
        }
    })
    
    function onWindowResize( event ) {
        //SCREEN_HEIGHT = window.innerHeight;
        //SCREEN_WIDTH  = window.innerWidth;
        renderer.setSize(viewportWidth, viewportHeight);
        camera.updateProjectionMatrix();
    }

    

    var viewport;
    var controls;   //built-in three.js controls will be attached to this
    var mouseDown = 0;  //holds whether a mouse button is currently pressed (can be broken I think)
    var timer = new THREE.Clock(); // used so we don't raytrace every frame
    
    //viewport size
    var viewportWidth = window.innerWidth;
    var viewportHeight = window.innerHeight;

    //camera attributes
    var view_angle = 45,
        aspect = viewportWidth / viewportHeight,
        near = 0.1,//near clip-plane
        far = 100000;//far clip-plane


    //----Constructors----//
    var renderer = new THREE.WebGLRenderer({antialias: true});

    var scene = new THREE.Scene();
    scene.fog = new THREE.Fog( 0xff0101, 100, 10000 );

    var raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.2;
    
    var camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);

    var pointCloud; // will store THREE geometry of point cloud
    var mouse = new THREE.Vector2(); // used to store x & y positions of mouse for raytracing
    var intersection = null; // placeholder for raytracing later
    var pointSize = 200.0; // size of particles
    // define and add the hover-over sphere
    var alphaTexture = new THREE.ImageUtils.loadTexture('alpha2.png');
    alphaTexture.wrapS = THREE.RepeatWrapping;
    alphaTexture.wrapT = THREE.RepeatWrapping;
    var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
    var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );
    var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xccccff, 
                                                        shading: THREE.FlatShading, 
                                                        alphaMap: alphaTexture, 
                                                        transparent: true } );
    var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
    scene.add( sphere );
    //a cross-browser method for efficient animation, more info at:
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame = (function(){ // this is witchcraft
      return  window.requestAnimationFrame       || 
              window.webkitRequestAnimationFrame || 
              window.mozRequestAnimationFrame    || 
              window.oRequestAnimationFrame      || 
              window.msRequestAnimationFrame     || 
              function( callback ){
                window.setTimeout(callback, 1000 / 60);
              };
    })();
    //----Initialization----//
    function initialize()
    {
        viewport = document.getElementById('viewport');  // find where the visualisation takes place
        renderer.setSize(viewportWidth, viewportHeight); // set the size of our scene
        viewport.appendChild(renderer.domElement); // add the renderer to the viewport
        camera.position.z=5.; // position the camera
        //attaches fly controls to the camera
        controls = new THREE.FlyControls( camera );
        //camera control properties
        controls.movementSpeed = 1;
        controls.domElement = viewport; // set the domain where the controls are active
        controls.rollSpeed = 0.01; // nice and slowly :P
        controls.autoForward = false; // we don't want to automatically move
        controls.dragToLook = true; // we want to only look around when clicking
        scene.add(camera); // add the camera to the scene
        update(); // call update to start program loop
    }
    //----Update----//
    function update() {
        requestAnimFrame( update ); //requests the browser to call update at it's own pace
        controls.update( 1 ); //update controls
        draw(); // draw the scene
    }
    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }
    function getDisplay(data_row){
        out = '';
        for (i=0; i<data_row.length; i++) {
            out += data_row[i]+"<br>";
        }
        return out;
    }
    var t = 0;
    function findIntersect(bar){
        raycaster.setFromCamera( mouse, camera );
        var intersections = raycaster.intersectObject( pointCloud );
        intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
        if (intersection && intersection.index){
            data_entry = foo[intersection.index+1];
            sphere.position.set(data_entry[1],data_entry[2],data_entry[3]);
            sphere.scale.set(4, 4, 4);
            $("#displayBox").html(getDisplay(data_entry));
            //console.log(foo[intersection.index]);
        } else {
            sphere.position.set(0,0,0);
            sphere.scale.set(.1, .1, .1);
        }
        t = timer.getElapsedTime();
    }
    //----Draw----//
    function draw() {
        if (!mouseDown && (timer.getElapsedTime()-t )> .3) {
            async(mouseDown, findIntersect); // mousedown only passed to satisfy async
        }
        renderer.render(scene, camera);
    }
    function onMouseDown(){ ++mouseDown; }
    function onMouseUp(){ --mouseDown; }
    window.addEventListener('resize', onWindowResize, false );
    window.addEventListener('mousemove', onDocumentMouseMove, false );
    document.addEventListener('mousedown', onMouseDown, false);
    document.addEventListener('mouseup', onMouseUp, false);
    window.requestAnimationFrame(draw);
</script> 
</head>
<body onload="initialize();">
<div id="viewport" style="width:100%;height:100%;position:fixed;"></div>
<div id='displayBox'>
    Hello!
</div>
</body>
</html>
